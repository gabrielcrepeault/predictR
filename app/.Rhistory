{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## 24 novembre 2018
## Gabriel Crépeault-Cauchon
## SIMULATION DE MOUVEMENT BROWNIENS
## Définition paramètres du mouvement
mu <- 0.03
sig <- 0.4
n <- 365 # nombre de jours dans une année ? (delta t petit ...)
## On va simuler ça un nombre de foix nsim
nsim <- 1000
brown.mvt <- function(mu, sig, n, start = 1)
{
## vecteur de t
t <- seq(0, 1, by = 1/n)
## simulation des mouvements
Yt <- rnorm(n, mu*t, sig*sqrt(t))
## donc, si on dit que notre titre a une valeur initiale de 10$, et qu'on applique les rendements
## simulés par Mouvements Brownien :
stock_price <- start * cumprod(exp(Yt))
}
plot(brown.mvt(mu, sig, n, 10))
## Tp Processus stochastique
## Question 1 ####
# Place le working directory au bon endroit automatiquement
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
#library
library('actuar')
library(ggplot2)
library(xtable) # pour faire les tables LaTeX pour le rapport
# Choix des distributions
# N_1 suit une loi de poisson(lambda * t)
# N_2 suit une loi de poisson(LAMBDA * t)
# LAMBDA suit une loi binomial(n, p)
# X suit une loi gamma(alpha, beta)
#Paramètres généraux
rm(list = ls())
nsimul <- 1e04
set.seed(13122018)
# Choix des paramètres
# paramètre t de la poisson composée
t <- 1
# N_1
lambda <- 1
# N_2 et LAMBDA
n <- 5
p <- 0.2
# X
alpha <- 3
beta <- 1/10000
1/10000
# simuler N1 et N2
N_1 <- data.frame(t = sapply(1:5,function(x) rpois(nsimul, lambda * x)))
N_2 <- data.frame(t = sapply(1:5,function(x) rpois(nsimul, rbinom(nsimul, n, p) * x)))
# xtable pour rapport (changer en-tête en LaTeX!)
xtable(
head(
data.frame(N_1, N_2)
)
)
#simuler X, S1 et S2
simulXS <- function(N, t)
{
# trouver les valeurs de X (groupés en liste par simulation)
x <- sapply(1:nsimul, function(i) rgamma(N[i,t], alpha, beta))
# trouver les valeurs de s (somme des listes)
s <- sapply(x, sum)
# Renvoi des résultats
list(X = unlist(x),
S = s)
}
EspN1 <- apply(N_1, 2, mean)
EspN2 <- apply(N_2, 2, mean)
xtable(data.frame(EspN1, EspN2)) # changer les titres de la première colonne
## a) Calculer la Pr(N_i(t) = n) ####
i <- 0:10
PrN_1 <- data.frame(t = outer(i, 1:5, Vectorize(function(i,t) mean(N_1[,t] == i))),
row.names = i)
PrN_2 <- data.frame(t = outer(i, 1:5, Vectorize(function(i,t) mean(N_2[,t] == i))),
row.names = i)
xtable(data.frame(PrN_1, PrN_2)) # changer les titres en LaTex
# b) et c) POUR N Calculer l'espérance de N_i(t) (pour chaque t) ####
(temptbl <- data.frame(
t = 1:5,
EspN1 = sapply(1:5, function(x) mean(N_1[,x])),
EspN2 = sapply(1:5, function(x) mean(N_2[,x])),
varN1 = sapply(1:5, function(x) var(N_1[,x])),
varN2 = sapply(1:5, function(x) var(N_2[,x]))
))
xtable(temptbl)
## b) et c) POUR X ####
(temptbl <- data.frame(
t = 1:5,
EspX1 = sapply(1:5, function(t) mean(simulXS(N_1, t)$X)),
EspX2 = sapply(1:5, function(t) mean(simulXS(N_2, t)$X)),
varX1 = sapply(1:5, function(t) var(simulXS(N_1, t)$X)),
varX2 = sapply(1:5, function(t) var(simulXS(N_2, t)$X))
))
xtable(temptbl)
## d) Calculer l'espérance et variance de S_i(t)
(temptbl <- data.frame(
t = 1:5,
EspS1 = sapply(1:5, function(t) mean(simulXS(N_1, t)$S)),
EspS2 = sapply(1:5, function(t) mean(simulXS(N_2, t)$S)),
varS1 = sapply(1:5, function(t) var(simulXS(N_1, t)$S)),
varS2 = sapply(1:5, function(t) var(simulXS(N_2, t)$S))
))
xtable(temptbl) # juste à changer les en-tête pour des math dans LaTeX
# valid
t <- 1:5
((t*n*p*alpha*(1 + t*alpha - t * alpha * p + alpha)) / beta^2) / 1e10
sapply(1:5, function(t) var(simulXS(N_2, t)$S)) / 1e10
### Question 1.2 ####
## a) Estimer la fonction de répartition F_S_i(t) ####
dev.off()
par(mfrow = c(2,3))
sapply(1:5, function(i){
plot(ecdf(simulXS(N_1, i)$S),
main = paste('t = ',i),
xlab = 'S_i(t)')
abline(v = (alpha * t[i] * lambda) / beta, col ="blue")
}
)
dev.off()
par(mfrow = c(2,3))
sapply(1:5, function(i){
plot(ecdf(simulXS(N_2, i)$S),
main = paste('t = ',i),
xlab = 'S_i(t)')
abline(v = (alpha * t[i] * n * p) / beta, col ='blue')
}
)
#### Graphique avec ggplot2
value_S1 <- lapply(1:5, function(x) simulXS(N_1, x)$S)
value_S2 <- lapply(1:5, function(x) simulXS(N_2, x)$S)
df1 <- data.frame(sapply(1:5, function(t) unlist(value_S1[[t]])))
colnames(df1) <- c('t_1','t_2','t_3','t_4','t_5')
table1 <- data.frame(key = c(rep("t_1", length(df1[,1])),
rep("t_2", length(df1[,2])),
rep("t_3", length(df1[,3])),
rep("t_4", length(df1[,4])),
rep("t_5", length(df1[,5]))),
value = c(df1[,1],
df1[,2],
df1[,3],
df1[,4],
df1[,5]))
ggplot(data = table1, aes(value, colour = key)) + stat_ecdf(geo = "step")
df2 <- data.frame(sapply(1:5, function(t) unlist(value_S2[[t]])))
colnames(df2) <- c('t_1','t_2','t_3','t_4','t_5')
table2 <- data.frame(key = c(rep("t_1", length(df2[,1])),
rep("t_2", length(df2[,2])),
rep("t_3", length(df2[,3])),
rep("t_4", length(df2[,4])),
rep("t_5", length(df2[,5]))),
value = c(df2[,1],
df2[,2],
df2[,3],
df2[,4],
df2[,5]))
ggplot(data = table2, aes(value, colour = key)) + stat_ecdf(geo = "step")
## b) Estimer les valeurs de VaR_k(S_i) et TVaR_k(s_i) ####
# on utilise kappa au lieu de alpha pour les niveaux de
# confiance
kappa <- c(0.95, 0.975, 0.99)
# voir notes Intro2, on cherche pour la VaR la position
# dans le vecteur de S_i la valeur qui fait que F_x(x) >= kappa
# Enregistrer les valeurs de S sinon les TVAR n'ont pas d'allure car on resimule
value_S1 <- lapply(1:5, function(x) simulXS(N_1, x)$S)
value_S2 <- lapply(1:5, function(x) simulXS(N_2, x)$S)
VaRS1 <- sapply(1:5, function(x) quantile(value_S1[[x]], probs = kappa))
VaRS2 <- sapply(1:5, function(x) quantile(value_S2[[x]], probs = kappa))
TVaRS1 <- sapply(1:5, function(t) sapply(1:3, function(i) mean(value_S1[[t]][value_S1[[t]] > VaRS1[i,t]])))
TVaRS2 <- sapply(1:5, function(t) sapply(1:3, function(i) mean(value_S2[[t]][value_S2[[t]] > VaRS2[i,t]])))
# pour la TVaR, on fait la moyenne de toutes les observatinos
# que la valeur trouvée pour la VaR
## QUESTION 2.1 ####
##
## BODY
body <- dashboardBody(
tabItems(
tabItem(
tabName = "data_analysis",
fluidRow(box(title = 'Résumé des données',
width = 12,
collapsible = T, collapsed = T,
verbatimTextOutput('data_summary')
)),
fluidRow(box(title = 'Tableau des données',
width = 12,
collapsible = T, collapsed = T,
DT::dataTableOutput('data_table')
)),
fluidRow(box(title = 'Visualisation graphique bivariée',
width = 12, collapsible = T, collapsed = T,
dropdownButton(
h3("Changer les variables"),
uiOutput('select_reponse'),
uiOutput('select_exogene'),
circle = TRUE, status = "success",
icon = icon("gear"), width = "300px",
tooltip = tooltipOptions(title = "Cliquez pour changer les paramètres!")
),
plotOutput('custom_plot')
))
),
tabItem( ## Régression linéaire ####
tabName = 'regression_lineaire',
box(title = 'Modèles à analyser',
color = 'blue',
collapse = T, width = 12,
fluidRow(
column(6, textAreaInput('formula_fit_1', 'Entrez la formule du modèle 1')),
column(6, textAreaInput('formula_fit_2', 'Entrez la formule du modèle 2'))
)
),
fluidRow( # avec les verbatim, il faut wrap dans fluidrow
box(title = 'Sommaire de R',
status = 'info', solidHeader = T,
collapsible = T, collapsed = T,
width = 12,
fluidRow(
column(6, verbatimTextOutput('summary_lm_1')),
column(6, verbatimTextOutput('summary_lm_2'))
)
)),
fluidRow( # avec les verbatim, il faut wrap dans fluidrow
box(title = 'ANOVA',
status = 'info', solidHeader = T,
collapsible = T, collapsed = T,
width = 12,
fluidRow(
column(6, verbatimTextOutput('anova_lm_1')),
column(6, verbatimTextOutput('anova_lm_2'))
)
)),
fluidRow( # avec les verbatim, il faut wrap dans fluidrow
box(title = "Test pour manque d'ajustement (Lack-of-fit)",
status = 'info', solidHeader = T,
collapsible = T, collapsed = T,
width = 12,
fluidRow(
column(6, verbatimTextOutput('lack_of_fit_lm_1')),
column(6, verbatimTextOutput('lack_of_fit_lm_2'))
)
)),
fluidRow( # avec les verbatim, il faut wrap dans fluidrow
box(title = 'Graphique des résidus (Homoscédasticité)',
status = 'info', solidHeader = T,
collapsible = T, collapsed = T,
width = 12,
fluidRow(
column(6, plotOutput('plot_residus_lm_1')),
column(6, plotOutput('plot_residus_lm_2'))
)
)),
fluidRow( # avec les verbatim, il faut wrap dans fluidrow
box(title = 'QQ Plot (normalité)',
status = 'info', solidHeader = T,
collapsible = T, collapsed = T,
width = 12,
fluidRow(
column(6, plotOutput('plot_qqplot_lm_1')),
column(6, plotOutput('plot_qqplot_lm_2'))
)
))
library(shinydashboard)
),
tabItem( # GLM-ui ####
tabName = 'glm',
tabsetPanel(
tabPanel('Analyse individuelle',
fluidRow(
tabBox(
tabPanel(title = 'Modèle',
textAreaInput('formula_glm_1', width = "300px",
'Entrez la formule du GLM'),
selectInput('glm1_family', 'Choisir la famille',
choices = c('binomial',
'gaussian',
'Gamma',
'inverse.gaussian',
'poisson')),
selectInput('glm1_link', 'Choisir la fonction de lien',
choices = c('logit',
'probit',
'identity',
'log',
'loglog')),
actionBttn("glm_add", label = 'Ajouter le modèle',
color = 'success', icon = icon('plus'))
),
tabPanel(title = 'Variables disponibles',
verbatimTextOutput("variables_name")
)
),
box(title = 'Analyse Drop1',
status = 'info', solidHeader = T,
verbatimTextOutput("drop1_glm_1"),
p('Test Chisq par défaut')
)),
fluidRow(
box(title = 'Summary de R', status = 'info',
solidHeader = T,
verbatimTextOutput('summary_glm_1')
),
box(title = 'Analyse ANOVA sur un modèle', status = 'info',
solidHeader = T,
verbatimTextOutput('anova_glm_1')
)
)
),
tabPanel(title = 'Comparaison',
box(title = "Modèles à comparer",
width = 12,
uiOutput('glm_compare')
)
)
)
)
)
)
library(shinydashboard)
library(shinyWidgets)
library(shiny)
shinyWidgetsGallery()
runApp('Box Sync/GitHub/predictR/app')
runApp('Box Sync/GitHub/predictR/app')
runApp('Box Sync/GitHub/predictR/app')
runApp('Box Sync/GitHub/predictR/app')
runApp('Box Sync/GitHub/predictR/app')
runApp('Box Sync/GitHub/predictR/app')
## Setup pour shinyapp.io server
## Tutoriel : https://shiny.rstudio.com/articles/shinyapps.html
library(rsconnect)
username <- 'gabrielcrepeault'
token <- 'F28807D3A18DE8EC270543DADDB10009'
secret <- 'RWQO8l6Y4SbsGnacpChCHzXYXrsJ/36SzgnUOmVl'
app_name = 'predictR'
rsconnect::setAccountInfo(username, token, secret)
setwd("~/Box Sync/GitHub/predictR/app/")
deployApp(appName = app_name)
## Setup pour shinyapp.io server
## Tutoriel : https://shiny.rstudio.com/articles/shinyapps.html
library(rsconnect)
username <- 'gabrielcrepeault'
token <- 'F28807D3A18DE8EC270543DADDB10009'
secret <- 'RWQO8l6Y4SbsGnacpChCHzXYXrsJ/36SzgnUOmVl'
app_name = 'predictR'
rsconnect::setAccountInfo(username, token, secret)
setwd("~/Box Sync/GitHub/predictR/app/")
deployApp(appName = app_name)
deployApp(appName = app_name)
library(nlme)
library(MASS)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(car)
library(ggplot2)
library(dplyr)
library(alr3)
library(DT)
deployApp(appName = app_name)
